<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&midast;&midast;Flynn Taxonomy&midast;&midast;</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 12px;
                line-height: 1;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <p>[[CPU Intrinsics Extension]]</p>
<hr>
<h3 id="flynn-taxonomy"><strong>Flynn Taxonomy</strong></h3>
<p>SIMD: Single instruction multiple data.</p>
<p>Here we will be interested in <strong>MIMD</strong>, multiple instructions multiple data.</p>
<p>First, we are going to assume that each cores are sharing memories with each other.</p>
<p>And then we will try to understand what a process is and how the OS interact with programs.</p>
<hr>
<h3 id="strategies-for-dividing-works"><strong>Strategies for Dividing Works</strong></h3>
<ol>
<li>On demand.</li>
<li>Pre-divide</li>
<li>Break up each &quot;work&quot; into multiple tasks</li>
</ol>
<p>Analogy:
Imagine you are a bunch of TAs.
Then: Exams are data.
Grading each question is: Task
Execution Units: TA.</p>
<hr>
<h3 id="single-core"><strong>Single Core</strong></h3>
<p>There is no such a thing as running the programs at the same time.</p>
<p>Concurrently: running at the same time.</p>
<hr>
<h3 id="pre-emptive-multi-threading">Pre-Emptive Multi-Threading</h3>
<p>This is  what the OS is doing.</p>
<p>When program is running a program, it has to switch to another task, like, the OS.</p>
<hr>
<h3 id="process-abstraction"><strong>Process Abstraction</strong></h3>
<p>Here is a list of information the abstraction is going to keep track of:</p>
<ul>
<li>Registers</li>
<li>Program Counter</li>
<li>Program Status word</li>
<li>Stack pointer</li>
<li>Process state</li>
<li>Priority</li>
<li>Scheduling parameters</li>
<li>Process ID</li>
<li>Parent Process</li>
<li>Process group</li>
<li>Signals</li>
<li>Time when process started</li>
<li>CPU time used</li>
<li>Children's CPU time</li>
<li>Time of the next alarm</li>
</ul>
<p>These information are all stored in the memory.</p>
<p>The abstraction allows the CPU to jumps between different process.</p>
<p>The process has its own virtual memory, that is it's own <strong>address space</strong></p>
<p>When swapping, the actual bits in the physical memory is disjoint, but the memory view by the program will be continuous.</p>
<hr>
<h3 id="process-life-time"><strong>Process Life Time</strong></h3>
<ol>
<li>Ready (IO finished, ready to go)</li>
<li>Running</li>
<li>Waiting (Reading files, system calls, IO calls)</li>
<li>New</li>
<li>Terminated</li>
</ol>
<p>The OS control all these states of the process.</p>
<p>The process can request the OS to manage. That is a system call. The OS then decide what to do with the process.</p>
<p>There is also a timer! That is associated with the process, it's about 100Hz.</p>
<hr>
<h3 id="context-switch"><strong>Context Switch</strong></h3>
<p>We want to provides an illusion for the user that things are happening at the same time.</p>
<p>We want to balance out the overhead of context switch and the illusion of responsiveness.</p>
<p>The switching is about 60 Hz.</p>
<hr>
<h3 id="fork"><strong>Fork</strong></h3>
<p>Fork: Process creation in UNIX</p>
<p>It's called once, and it will return TWICE.</p>
<p>The <code>fork()</code> will make a child process of the current process.</p>
<p>Everything that comes after the <code>fork()</code> will be executed in the parent process, and the child process.</p>
<p>It will return zero if the current process successfully created the child process.</p>
<p>Let's take a look at what we call a <code>Fork Bomb</code>:</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> pids[<span class="hljs-number">20</span>]; 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)
    {
        pids[i] = fork();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>And, this will spawn 2 on the first process, each child process then go ahead and spawn 2 again.</p>
<p>The total number of spawned process is like:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mn>20</mn></munderover><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\sum_{n = 0}^{20}
    2^{n}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.068226em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>To spawn 20 processes properly, we should ues this:</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">pid_t</span> pids[<span class="hljs-number">20</span>]; 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)
    { 
        pids[i] = fork();
        <span class="hljs-keyword">if</span> (pids[i] == <span class="hljs-number">0</span>) 
        {<span class="hljs-keyword">break</span>;}
    }
}
</div></code></pre>
<p>This is saying that, if the current process we looking at, already spawned its parent, then we are quitting the for loop all together.</p>
<hr>
<h3 id="context-switching-problem"><strong>Context Switching Problem</strong></h3>
<p>This is called the <strong>race conditions</strong>.</p>
<p>This will produce incorrect results, if, context switching between different threads can give different results.</p>
<p>Classically, you can't sum up a number using multiple threads, while that integer is shared among different threads.</p>
<p><strong>Critical Section Problem Solution</strong>:</p>
<ul>
<li>Mutual Exclusion: Instruction cannot intersect. No process can execute the critical section at the same time.</li>
<li>Progress: The selection of the process to enter the critical section cannot postpone indefinitely.</li>
<li>Bounded Waiting: A bound must exists on the number of time that other process are allowed to enter the critical section.</li>
</ul>
<p><strong>Locking While loop (Failed)</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">while</span> (lock);  <span class="hljs-comment">// infinite spin. </span>
<span class="hljs-comment">// Race conditions here! </span>
lock = <span class="hljs-literal">true</span>; 
dothings();
lock = <span class="hljs-literal">false</span>; 
</div></code></pre>
<p>Whenever a process require access to the critical section, it checks the lock, while it's locked, it waits, when it's true, we will do things and release the lock.</p>
<p>Ok, what if there is a race condition on the <code>lock</code> variable.</p>
<p>Thread 1 got access, thread 2 got access 2.</p>
<p>Context switch between these 2 thread, right before setting the lock to true.</p>
<p>Boom, now we have 2 thread setting the lock to TRUE.</p>
<p>Hence, do something will be executed in 2 threads at the same time.</p>
<p>The essence is:</p>
<p><strong>We are checking some predicate, and then take some action on the shared variable.</strong> But to achieve mutual exclusion, we have to have both steps as an inseparable procedure.</p>

    </body>
    </html>